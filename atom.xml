<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>心动果果の博客</title>
  
  
  <link href="http://yunduoii.github.io/atom.xml" rel="self"/>
  
  <link href="http://yunduoii.github.io/"/>
  <updated>2024-03-14T05:57:48.350Z</updated>
  <id>http://yunduoii.github.io/</id>
  
  <author>
    <name>Guo Yuling</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习毕设</title>
    <link href="http://yunduoii.github.io/post/52f2eb04.html"/>
    <id>http://yunduoii.github.io/post/52f2eb04.html</id>
    <published>2024-03-08T04:38:04.000Z</published>
    <updated>2024-03-14T05:57:48.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数库基本用法"><a href="#函数库基本用法" class="headerlink" title="函数库基本用法"></a>函数库基本用法</h1><h2 id="一、数据预处理"><a href="#一、数据预处理" class="headerlink" title="一、数据预处理"></a>一、数据预处理</h2><h3 id="1-os-walk"><a href="#1-os-walk" class="headerlink" title="1.os.walk()"></a>1.os.walk()</h3><p>os.walk() 方法用于通过在目录树中游走输出在目录中的文件名，向上或者向下。<br>os.walk() 方法是一个简单易用的文件、目录遍历器，可以帮助我们高效的处理文件、目录方面的事情。<br>os.walk(data_dir)<br>data_dir– 是你所要遍历的目录的地址, 返回的是一个三元组(root,dirs,files)。</p><p>root 所指的是当前正在遍历的这个文件夹的本身的地址<br>dirs 是一个 list ，内容是该文件夹中所有的目录的名字(不包括子目录)<br>files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</p><h4 id="Python-os-walk-方法"><a href="#Python-os-walk-方法" class="headerlink" title="Python os.walk() 方法"></a>Python os.walk() 方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def walkFile(file):</span><br><span class="line">    for root, dirs, files in os.walk(file):</span><br><span class="line"></span><br><span class="line">        # root 表示当前正在访问的文件夹路径</span><br><span class="line">        # dirs 表示该文件夹下的子目录名list</span><br><span class="line">        # files 表示该文件夹下的文件list</span><br><span class="line"></span><br><span class="line">        # 遍历文件</span><br><span class="line">        for f in files:</span><br><span class="line">            print(os.path.join(root, f))</span><br><span class="line"></span><br><span class="line">        # 遍历所有的文件夹</span><br><span class="line">        for d in dirs:</span><br><span class="line">            print(os.path.join(root, d))</span><br></pre></td></tr></table></figure><h4 id="Python-os-path-模块"><a href="#Python-os-path-模块" class="headerlink" title="Python os.path 模块"></a>Python os.path 模块</h4><p>os.path.join(path1[, path2[, …]])    指把目录和文件合成一个路径</p><h4 id="Matplotlib-imshow-方法"><a href="#Matplotlib-imshow-方法" class="headerlink" title="Matplotlib imshow() 方法"></a>Matplotlib imshow() 方法</h4><p>img = Image.open(path)，这是PIL中的一个处理图片的函数，使用时需 from PIL import Image</p><p>在使用 <strong>matplotlib</strong> 绘图时，如果需要图例、标题、坐标轴标签等显示中文，你可以按照以下步骤解决中文乱码问题：</p><ol><li><p><strong>快速解决方法</strong>： 在导入 <strong>matplotlib</strong> 模块后，加入以下代码：</p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 设置字体样式以正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 默认是使用 Unicode 负号，设置正常显示字符，如正常显示负号</span></span><br></pre></td></tr></table></figure><p>AI 生成的代码。仔细查看和使用。 <a href="https://www.bing.com/new#faq">有关常见问题解答的详细信息</a>.</p><p>如果仍无法解决，可以尝试使用其他字体，如 <code>&#39;FangSong&#39;</code>。</p></li></ol><p>Plt库</p><p>plt.scatter 作出散点图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(width_list, height_list, s=1)</span><br><span class="line">plt.xlabel(&quot;宽&quot;)</span><br><span class="line">plt.ylabel(&quot;高&quot;)</span><br><span class="line">plt.title(&quot;图像宽高分布&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>从散点图可以看出<strong>样本的分辨率不均匀</strong></p><p><img src="/post/image-20240311105210901.png"></p><p> 遇到的问题：</p><p>图像宽高过大和过小</p><p>图像宽高比列不协调</p><p>保持图像宽高在200-2000内，宽/高&gt;=0.5</p><h3 id="删除不必要图片"><a href="#删除不必要图片" class="headerlink" title="删除不必要图片"></a>删除不必要图片</h3><p><img src="/post/image-20240311204546624.png" alt="image-20240311204546624"></p><p>再运行一次，已经删干净了</p><p><img src="/post/image-20240311204614449.png" alt="image-20240311204614449"></p><p>继续作出柱状图</p><p>file_num_list.append(len(files))</p><p>解释：</p><ol><li><code>file_num_list</code> 是一个 <strong>列表</strong>（也称为数组），它存储了一些文件的数量或其他相关数据。</li><li><code>append(len(files))</code> 是一个 <strong>方法调用</strong>，它将文件列表 <code>files</code> 的长度添加到 <code>file_num_list</code> 中。具体来说，<code>len(files)</code> 返回 <code>files</code> 列表中元素的数量，然后 <code>append()</code> 方法将这个数量添加到 <code>file_num_list</code> 的末尾。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_positions = np.arange(len(file_name_list))</span><br></pre></td></tr></table></figure><p>len(file_name_list) 返回文件名列表 file_name_list 中元素的数量。<br>np.arange() 创建一个等差数组，其参数可以是起始值、终止值和步长。在这里，我们没有指定步长，因此默认为 1。<br>因此，np.arange(len(file_name_list)) 将生成一个从 0 到 len(file_name_list) - 1 的整数数组。</p><p><code>ax.set_xticklabels(file_name_list, rotation=90)</code> 是 <strong>Matplotlib</strong> 中的一个函数。让我来解释一下：</p><ul><li><code>ax</code> 表示 <strong>Axes</strong> 对象，它是绘图的一个子区域，通常对应于图中的一个坐标轴（例如 x 轴或 y 轴）。</li><li><code>set_xticklabels()</code> 是一个用于设置 x 轴刻度标签的方法。</li><li><code>file_name_list</code> 是一个列表，包含了你想要作为 x 轴刻度标签的字符串。</li><li><code>rotation=90</code> 表示将刻度标签旋转 90 度，以便更好地适应图形。</li></ul><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_xticklabels.html">总之，这个函数的作用是在 Matplotlib 图中设置 x 轴的刻度标签为给定的字符串列表，并将它们旋转 90 度。这在需要自定义刻度标签时非常有用</a></p><p><code>file_num_list = file_num_list[1:]</code> 是一个 Python 代码片段，让我来解释一下：</p><ul><li><code>file_num_list</code> 是一个列表（或数组）。</li><li><code>file_num_list[1:]</code> 表示从列表的第二个元素开始（索引为 1），截取到列表的最后一个元素。这样，新的列表 <code>file_num_list</code> 就不再包含原列表的第一个元素。</li></ul><p>例如，如果原始列表 <code>file_num_list</code> 是 <code>[10, 20, 30, 40, 50]</code>，执行 <code>file_num_list = file_num_list[1:]</code> 后，<code>file_num_list</code> 将变成 <code>[20, 30, 40, 50]</code>。</p><p>这个操作通常用于删除列表中的第一个元素或截取部分数据。</p><p>ax.histogram(histogram_positions, file_num_list, 0.5)` 是一个绘制直方图的操作。</p><ul><li><code>ax</code> 表示 <strong>Axes</strong> 对象，它是绘图的一个子区域，通常对应于图中的一个坐标轴（例如 x 轴或 y 轴）。</li><li><code>histogram_positions</code> 是一个列表，包含了直方图的位置信息。</li><li><code>file_num_list</code> 是一个列表，包含了你想要绘制直方图的数据。</li><li><code>0.5</code> 是直方图的柱子宽度。</li></ul><p>总之，这个函数的作用是在 <strong>Matplotlib</strong> 图中绘制一个直方图，使用给定的位置信息和数据。</p><p>柱状图发现<strong>样本数量不均匀</strong></p><p><img src="/post/image-20240311105232833.png" alt="image-20240311105232833"></p><p>经过一系列处理后，再次生成散点图和柱状图</p><p><img src="/post/image-20240312132729299.png" alt="image-20240312132729299"></p><p><img src="/post/image-20240312132754410.png" alt="image-20240312132754410"></p><p>从上面可以看出数据处理了一部分，但是效果没有太好</p><h3 id="三、数据增强"><a href="#三、数据增强" class="headerlink" title="三、数据增强"></a>三、数据增强</h3><p>对样本比较少的类别进行数据增强</p><p>数据增强：水平翻转、垂直翻转</p><p>之后样本比较少的数据集可以增加数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.flip(image,1,dst=None)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;image.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平翻转图像</span></span><br><span class="line">flipped_image = cv2.flip(image, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存翻转后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">&quot;flipped_image.jpg&quot;</span>, flipped_image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印成功消息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;图像已水平翻转并保存为 flipped_image.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><p>AI-generated code. Review and use carefully. <a href="https://www.bing.com/new#faq">More info on FAQ</a>.</p><p>在这个示例中，我们使用了 <code>cv2.flip</code> 方法来水平翻转图像。你可以根据你的需求进行相应的调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir_loc = os.path.split(split[0])[1]</span><br></pre></td></tr></table></figure><p><code>dir_loc</code> 是一个变量，它的值是 <code>split[0]</code> 的路径中的最后一个目录。在这个表达式中，<code>os.path.split(split[0])</code> 会将 <code>split[0]</code> 分割成目录和文件名的元组。然后，我们选择元组的第二个元素，即目录部分，作为 <code>dir_loc</code> 的值。</p><p>如果你需要更多关于 <code>os.path.split</code> 函数的信息，可以查阅 Python 官方文档。</p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 split[0] 是一个文件路径，例如 &quot;/home/user/documents/file.txt&quot;</span></span><br><span class="line">split = [<span class="string">&quot;/home/user/documents/file.txt&quot;</span>]</span><br><span class="line">dir_loc = os.path.split(split[<span class="number">0</span>])[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文件所在目录：<span class="subst">&#123;dir_loc&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>AI-generated code. Review and use carefully. <a href="https://www.bing.com/new#faq">More info on FAQ</a>.</p><p>这段代码会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件所在目录：documents</span><br></pre></td></tr></table></figure><p><strong>split = os.path.split(file_i_path)</strong></p><p><code>split</code> 是一个变量，它的值是 <code>file_i_path</code> 的路径中的目录和文件名的元组。在这个表达式中，<code>os.path.split(file_i_path)</code> 会将 <code>file_i_path</code> 分割成目录和文件名的元组。然后，我们选择元组的第二个元素，即文件名部分，作为 <code>split</code> 的值。</p><p>如果你需要更多关于 <code>os.path.split</code> 函数的信息，可以查阅 Python 官方文档。</p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 file_i_path 是一个文件路径，例如 &quot;/home/user/documents/file.txt&quot;</span></span><br><span class="line">file_i_path = <span class="string">&quot;/home/user/documents/file.txt&quot;</span></span><br><span class="line">split = os.path.split(file_i_path)</span><br><span class="line">file_name = split[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文件名：<span class="subst">&#123;file_name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>AI-generated code. Review and use carefully. <a href="https://www.bing.com/new#faq">More info on FAQ</a>.</p><p>这段代码会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件名：file.txt</span><br></pre></td></tr></table></figure><p>经过数据增强后的图：</p><p><img src="/post/image-20240313142545809.png" alt="image-20240313142545809"></p><p><img src="/post/image-20240313142602921.png" alt="image-20240313142602921"></p><h3 id="数据平衡"><a href="#数据平衡" class="headerlink" title="数据平衡"></a>数据平衡</h3><p><img src="/post/image-20240313223121132.png" alt="image-20240313223121132"></p><p><img src="/post/image-20240313223135973.png" alt="image-20240313223135973"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数库基本用法&quot;&gt;&lt;a href=&quot;#函数库基本用法&quot; class=&quot;headerlink&quot; title=&quot;函数库基本用法&quot;&gt;&lt;/a&gt;函数库基本用法&lt;/h1&gt;&lt;h2 id=&quot;一、数据预处理&quot;&gt;&lt;a href=&quot;#一、数据预处理&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="函数库基本用法" scheme="http://yunduoii.github.io/tags/%E5%87%BD%E6%95%B0%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yunduoii.github.io/post/0.html"/>
    <id>http://yunduoii.github.io/post/0.html</id>
    <published>2023-04-01T15:40:56.507Z</published>
    <updated>2024-03-08T04:38:35.423Z</updated>
    
    <content type="html"><![CDATA[<p>UE5 UI基础</p><p><img src="/post/myboke/hexoo/source/_posts/Unity/image-20230330234040600.png" alt="image-20230330234040600"></p><p><img src="/post/myboke/hexoo/source/_posts/Unity/image-20230330234932299.png" alt="image-20230330234932299"></p><p><img src="/post/image-20230402142535133.png" alt="image-20230402142535133"></p><p><img src="/post/image-20230402143353014.png" alt="image-20230402143353014"></p><p><img src="/post/image-20230402144438310.png" alt="image-20230402144438310"></p><p><img src="/post/image-20230402145556415.png" alt="image-20230402145556415"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UE5 UI基础&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post/myboke/hexoo/source/_posts/Unity/image-20230330234040600.png&quot; alt=&quot;image-20230330234040600&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity</title>
    <link href="http://yunduoii.github.io/post/c8a4b253.html"/>
    <id>http://yunduoii.github.io/post/c8a4b253.html</id>
    <published>2023-03-14T15:42:46.000Z</published>
    <updated>2023-03-15T14:27:02.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity游戏豆腐工艺"><a href="#Unity游戏豆腐工艺" class="headerlink" title="Unity游戏豆腐工艺"></a>Unity游戏豆腐工艺</h1><h2 id="1、游戏概况"><a href="#1、游戏概况" class="headerlink" title="1、游戏概况"></a>1、游戏概况</h2><p>主要内容：开发工具介绍、游戏名称、游戏类型、游戏风格、游戏特点、目标用户定位、游戏创意点说明。(600字以内，可附必要的图片)</p><p><strong>开发工具</strong>：Unity 3D</p><img src="/post/c8a4b253/image-20230315100204139.png" class title="游戏制作工具"><p><img src="/post/image-20230315100204139.png" alt="image-20230315100204139"></p><p><strong>游戏名称</strong>：豆腐工坊   </p><p><strong>游戏类型</strong>：角色扮演 模拟动作   </p><p><strong>游戏风格</strong>：轻松 古风   </p><p><strong>游戏特点</strong>：在日常生活中，我们很少能亲眼看见豆腐的制作过程，但这是我们文化中很重要的一道美食。在这款游戏中玩家扮演的角色，可以跟着流程体验传统工艺制作豆腐，感受其中的乐趣，玩法简单，同时豆腐工坊位处古代市井中，玩家也可以体验到不一样的繁华街市。   目标用户：全年龄向，想要体验豆腐加工工序的人   创意：首先在游戏玩法上，我们摒弃了传统游戏复杂且庞大的玩法机制，旨在更好的让大家直观的体验到豆腐的制作工艺，其次我们将游戏的场景设定在古代的街市中，为了让大家更好的了解传统文化，以及获得更好的沉浸式体验。   </p><h2 id="2、游戏构思"><a href="#2、游戏构思" class="headerlink" title="2、游戏构思"></a>2、游戏构思</h2><h3 id="主要内容-描述背景故事、故事主线提纲、关卡设计、创意元素等。"><a href="#主要内容-描述背景故事、故事主线提纲、关卡设计、创意元素等。" class="headerlink" title="主要内容:描述背景故事、故事主线提纲、关卡设计、创意元素等。"></a><strong>主要内容</strong>:描述背景故事、故事主线提纲、关卡设计、创意元素等。</h3><h3 id="故事背景："><a href="#故事背景：" class="headerlink" title="故事背景："></a><strong>故事背景</strong>：</h3><p>明朝永乐年间，在京师有一家名不经传的豆腐坊，店主是这家豆腐坊的第六代传人，但事实上他只见过他父亲做豆腐，其他人他没见过，但是他的父亲已年迈不能再进行一些体力活了，便把做豆腐的技艺传给了我，但是我深知只靠我一个人很难将这门技术发扬光大，所以我来到了我们家位于市井深处的院子，向大家展示做豆腐店的工艺流程，将这门技艺传授给所有到场学习的人。</p><h3 id="主线："><a href="#主线：" class="headerlink" title="主线："></a><strong>主线</strong>：</h3><p>古书《<a href="https://zh.wikipedia.org/wiki/%E6%9C%AC%E8%8D%89%E7%BA%B2%E7%9B%AE">本草纲目</a>》谷部卷25”豆腐”：“凡黑豆、黄豆及白豆、泥豆、豌豆、绿豆之类，皆可为之。水浸，硙碎。滤去渣，煎成。以卤汁或山矾叶或酸浆醋淀，就釜收之。”简述其生产过程是：选豆一浸豆→磨豆→滤浆→煮浆→点浆→成型，这也就是传统豆腐生产的基本过程。主角将在庭院中展示所有这些技艺。</p><h3 id="关卡设计："><a href="#关卡设计：" class="headerlink" title="关卡设计："></a><strong>关卡设计</strong>：</h3><p>玩家通过提示完成豆腐的制作流程，但是每个步骤有相应的前后顺序玩家需要通过提示，完成相应的步骤，出错会提示，完成后会出现做好的豆腐动画，每一个步骤都是按照现实生活中的步骤设计的非常有代入感。</p><h4 id="1、滤豆设计"><a href="#1、滤豆设计" class="headerlink" title="1、滤豆设计"></a>1、滤豆设计</h4><p><video src="./../../../../qq/lvdou.mp4"></video></p><p><video src="./Unity/modou.mp4"></video></p><p><strong>创意元素</strong>：古风的游戏场景和传统的制作工艺。</p><h2 id="3、设计元素"><a href="#3、设计元素" class="headerlink" title="3、设计元素"></a>3、设计元素</h2><h3 id="角色设计："><a href="#角色设计：" class="headerlink" title="角色设计："></a>角色设计：</h3><p>角色是一位老者，在普遍的的印象当中一个人的年纪和他的生活阅历是划等号的，所以用老人的形象来表现他的专业和娴熟</p><h3 id="道具设计："><a href="#道具设计：" class="headerlink" title="道具设计："></a>道具设计：</h3><p>筛豆子需要的筛子，磨豆子需要的磨盘和水桶，房屋内部的装饰，具有农家特色的瓶瓶罐罐，还有烹饪的大锅以及压豆腐的模型。</p><h3 id="地图场景设计："><a href="#地图场景设计：" class="headerlink" title="地图场景设计："></a>地图场景设计：</h3><p>在一个古代的闹市中，市井深处有一户人家，我们的主场景是繁华的街市，采用古代常见的中轴线设计，展现出城市的恢弘和繁华，线性的地图增加玩家探索性的同时，也让玩家能够完整的体验整个场景。</p><img src="/post/c8a4b253/clip_image002-1678846277240-5.jpg" class title="游戏场景"><p><img src="/post/clip_image002-1678846277240-5.jpg" alt="img"></p><p>图 2地图场景</p><h3 id="UI设计："><a href="#UI设计：" class="headerlink" title="UI设计："></a>UI设计：</h3><p>本作UI尽量做到与游戏风格的统一，在交互和物品栏都使用了古风的元素，并且在界面中也加入了一些豆腐的元素让玩家时刻沉浸在制作豆腐中。</p><h4 id="开始界面"><a href="#开始界面" class="headerlink" title="开始界面"></a>开始界面</h4><img src="/post/c8a4b253/clip_image004.jpg" class><p> <img src="/post/clip_image004.jpg" alt="img">            </p><p>设置界面：</p><p>头像框：                                                                             </p><img src="/post/c8a4b253/image-20230314234349940.png" class title="This is an test image"><p><img src="/post/image-20230314234349940.png" alt="image-20230314234349940"></p><p>音乐美术资源：均为网上下载可自用模型，以及自己参考建模</p><p>以下为链接：</p><h2 id="4、游戏机制"><a href="#4、游戏机制" class="headerlink" title="4、游戏机制"></a>4、游戏机制</h2><h3 id="基本规则和流程"><a href="#基本规则和流程" class="headerlink" title="基本规则和流程"></a>基本规则和流程</h3><p>玩家操作角色，按照现实生活中做豆腐的流程，完成制作豆腐。</p><h3 id="游戏操作"><a href="#游戏操作" class="headerlink" title="游戏操作"></a>游戏操作</h3><p>操作简单易上手，只需要W A S D和交互键以及鼠标</p><h3 id="玩法核心"><a href="#玩法核心" class="headerlink" title="玩法核心"></a>玩法核心</h3><p>让人们全流程体验制作豆腐的乐趣</p><h3 id="乐趣点"><a href="#乐趣点" class="headerlink" title="乐趣点"></a>乐趣点</h3><p>体验制作工艺，沉浸在古代场景中。</p><h2 id="5、流程设计"><a href="#5、流程设计" class="headerlink" title="5、流程设计"></a>5、流程设计</h2><p>1、先将豆子取出进行筛豆</p><p>2、将豆子浸泡，并把豆子放入磨盘中进行研磨</p><p>3、取出豆浆过滤后倒入锅中进行熬煮</p><p>4、把煮好的豆浆放进模具中</p><p>5、压好豆腐后可以制作菜肴</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Unity游戏豆腐工艺&quot;&gt;&lt;a href=&quot;#Unity游戏豆腐工艺&quot; class=&quot;headerlink&quot; title=&quot;Unity游戏豆腐工艺&quot;&gt;&lt;/a&gt;Unity游戏豆腐工艺&lt;/h1&gt;&lt;h2 id=&quot;1、游戏概况&quot;&gt;&lt;a href=&quot;#1、游戏概况&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UnityUI的使用</title>
    <link href="http://yunduoii.github.io/post/4a17b156.html"/>
    <id>http://yunduoii.github.io/post/4a17b156.html</id>
    <published>2023-02-27T10:47:08.573Z</published>
    <updated>2023-03-14T15:35:27.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Unity-UI"><a href="#Unity-UI" class="headerlink" title="Unity UI"></a>Unity UI</h2><h2 id="1、初步认识"><a href="#1、初步认识" class="headerlink" title="1、初步认识"></a>1、初步认识</h2><h3 id="Canvas组件"><a href="#Canvas组件" class="headerlink" title="Canvas组件"></a>Canvas组件</h3><h4 id="Canvas-Overlay模式"><a href="#Canvas-Overlay模式" class="headerlink" title="Canvas-Overlay模式"></a>Canvas-Overlay模式</h4><p>Pixel Perpect:高像素清晰度渲染。</p><p>Sort Order：多Canvas时，用来控制哪个画布在前面显示。</p><h4 id="Canvas-Camera模式"><a href="#Canvas-Camera模式" class="headerlink" title="Canvas-Camera模式"></a>Canvas-Camera模式</h4><p>Plane Distance：用来调节画布与摄像机贴合距离</p><p><img src="/post/myboke\hexoo\source_posts\imgg\image-20230302210102899.png" alt="image-20230302210102899"></p><p>Order in Layer:Sorting Layer（排序层）和Order in Layer相同时，距离相近越近，越靠前。</p><p>Sorting Layers如下：</p><p><img src="/post/image-20230302213323710-1678587778743-1.png"></p><p>双相机叠加</p><ol><li>建立Camera</li><li>将UI相机拖给Canvas</li><li>将UI的相机设置为使用深度值填充，UI相机的深度要高于主相机</li><li>将主相机不渲染UI元素，将UI相机只渲染UI元素（Culling Mask为UI模式）</li></ol><h4 id="Canvas-World模式"><a href="#Canvas-World模式" class="headerlink" title="Canvas-World模式"></a>Canvas-World模式</h4><p>Canvas以3D物体的形式显示在场景中。</p><h3 id="Canvas缩放"><a href="#Canvas缩放" class="headerlink" title="Canvas缩放"></a>Canvas缩放</h3><p>​            <img src="/post/myboke\hexoo\source_posts\imgg\clip_image001.png" alt="img"></p><p>​          该组件会拉伸所有Canvas下的子元素</p><p><img src="/post/myboke\hexoo\source_posts\imgg\image-20230303210253258.png" alt="image-20230303210253258"></p><h4 id="Constant-Pixel-Size"><a href="#Constant-Pixel-Size" class="headerlink" title="Constant Pixel Size"></a>Constant Pixel Size</h4><p>默认模式，默认静态拉伸。</p><h4 id="Sacle-With-Screen-Size（常用）"><a href="#Sacle-With-Screen-Size（常用）" class="headerlink" title="Sacle With Screen Size（常用）"></a>Sacle With Screen Size（常用）</h4><p>根据UI设计师给的图片进行适配：</p><p><img src="/post/myboke\hexoo\source_posts\imgg\image-20230303211354331.png" alt="image-20230303211354331"></p><p>根据宽度或者高度进行自动拉伸，自动计算。</p><p><strong>一定要恢复原始大小 Set Native Size！！！</strong></p><p>计算方法：18:9下：缺失两边，（设计分辨率高度 / 9）* 18</p><p>​                   16:9下：美术一般都会按照16:9出图</p><p>​                   4:3下：缺失上下，（设计分辨率宽度 / 4）* 3</p><h4 id="Constant-Physical-Size"><a href="#Constant-Physical-Size" class="headerlink" title="Constant Physical Size"></a>Constant Physical Size</h4><p>物理模式，根据英寸进行计算，不常用。</p><h4 id="RectTransform组件"><a href="#RectTransform组件" class="headerlink" title="RectTransform组件"></a>RectTransform组件</h4><p>​          出现位置：出现在所有Canvas子元素中，所有UI元素都应该有RectTransform组件</p><p><img src="/post/myboke\hexoo\source_posts\imgg\image-20230303212624739.png" alt="image-20230303212624739"></p><p>Pos（XYZ）：位置（X，Y，Z），单位（像素），<strong>位置是由轴点到锚点的距离</strong></p><p>Width，Height：宽和高，单位（像素）</p><p> Anchors：锚点（四叶草），<strong>以父物体参考</strong></p><p>这里X和Y的值为物体锚点（四叶草）到轴点（中心点）的距离</p><p><img src="/post/myboke\hexoo\source_posts\imgg\image-20230303212807963.png" alt="image-20230303212807963"></p><p>改成Pivot模式，可以改动轴点。</p><p>UGUI先进方式：<strong>双锚点</strong></p><p>shift 快捷调节锚点，alt快捷移动</p><p>单锚点：距离计算是锚点到轴点的XYZ偏移</p><p>​              双锚点：元素边界到锚线的距离，轴点到锚线的距离</p><p>​              四锚点：元素的四个边界到锚框的距离</p><p>​          锚点快速选择工具（十字符号）</p><p>​               默认：移动锚点</p><p>​              Alt：移动锚点+快速停靠位置</p><p>​              Shift：移动锚点+移动轴点+快速停靠位置</p><p>元素渲染顺序</p><p>​     以Hierarchy参考</p><p>下方物体在上方物体前显示</p><p>子物体在父物体前显示</p><p>下方物体永远在前显示，无论上方的层次结构</p><p><img src="/post/image-20230307141541165.png" alt="image-20230307141541165"></p><h2 id="2、UGUI的基础组件"><a href="#2、UGUI的基础组件" class="headerlink" title="2、UGUI的基础组件"></a>2、UGUI的基础组件</h2><h3 id="Panel组件"><a href="#Panel组件" class="headerlink" title="Panel组件"></a>Panel组件</h3><p><strong>一个完整页面一个Panel</strong></p><p>Panel和Canvas一样大，Canvas和屏幕一样大。（四锚点）</p><h3 id="Text组件"><a href="#Text组件" class="headerlink" title="Text组件"></a>Text组件</h3><p><img src="/post/image-20230307143127429.png" alt="image-20230307143127429"></p><p>文本内容</p><p>​              字库选择</p><p>​              字体样式（标准，粗体，斜体，粗斜体）</p><p>​              字号</p><p>​              行间距</p><p>​              是否开启富文本</p><p>​                   加粗：<b>文字</b></p><p>斜体：<i>文字</i></p><p>大小：&lt;size=字号&gt;文字</p><p>修改颜色：&lt;color=颜色名&gt;文字</p><p>​           &lt;color=#颜色数（十六进制）&gt;文字</p><p>对齐方式（上下对齐，左右对齐）</p><p>几何对齐（参考字占用的几何空间）</p><p>水平溢出（折行，溢出[出右边框]）</p><p>垂直溢出（截断不显示，溢出[出下边框]）</p><p>​              字号自适应 best fit</p><p>​                   关闭：使用原始字号</p><p>​                   开启：字号会在最小值和最大值之间自动调整</p><p>​              字体颜色</p><p>  阴影</p><p><img src="/post/image-20230307150107721.png" alt="image-20230307150107721"></p><p>外发光</p><p><img src="/post/image-20230307150145347.png" alt="image-20230307150145347"></p><h3 id="Image组件"><a href="#Image组件" class="headerlink" title="Image组件"></a>Image组件</h3><p>Color：用于混色，美术有时提供白图和色号，程序员对图处理，染成想要的颜色，可以减少包体大小。</p><p>四种类型图片</p><h4 id="（1）普通模式"><a href="#（1）普通模式" class="headerlink" title="（1）普通模式"></a>（1）普通模式</h4><p>Preserve Aspect：保持图片的宽高比，高度或宽度自适应</p><p>Set Native Size：可以快速恢复美术提供的图片原始像素尺</p><h4 id="（2）裁剪模式"><a href="#（2）裁剪模式" class="headerlink" title="（2）裁剪模式"></a>（2）裁剪模式</h4><p>Split Editor：进行拉伸</p><p><img src="/post/image-20230307152154187.png" alt="image-20230307152154187"></p><p><img src="/post/image-20230307152224641.png" alt="image-20230307152224641"></p><p><img src="/post/image-20230307152319078.png" alt="image-20230307152319078"></p><p>1,3,7,9区域不拉伸</p><p>2,8横向拉伸</p><p>4,6纵向拉伸</p><h4 id="（3）瓦片模式（无缝贴图）"><a href="#（3）瓦片模式（无缝贴图）" class="headerlink" title="（3）瓦片模式（无缝贴图）"></a>（3）瓦片模式（无缝贴图）</h4><p>Tiled模式</p><p><img src="/post/image-20230308110255299.png" alt="image-20230308110255299"></p><h4 id="（4）填充模式"><a href="#（4）填充模式" class="headerlink" title="（4）填充模式"></a>（4）填充模式</h4><p>Fill Method：填充方式（360度，水平和垂直）</p><p>​                        Fill Origin：填充起始点</p><p>​                        Fill Amount：填充百分比</p><p>​                        Clockwise：顺时针或逆时针</p><p>​                        Preserve Aspect：保持图片的宽高比，高度或宽度自适应</p><p>​                        Set Native Size：可以快速恢复美术提供的图片原始像素尺寸</p><p>clockwise：控制顺逆时针</p><h3 id="Raw-Image组件"><a href="#Raw-Image组件" class="headerlink" title="Raw Image组件"></a>Raw Image组件</h3><p>​              原始图片组件：可以显示精灵或纹理</p><p>​              功能相对于Image少，所以性能更好</p><p>​              可以控制UV的偏移，来显示精灵的一部分</p><p><img src="/post/image-20230308201742994.png" alt="image-20230308201742994"></p><h2 id="3、UI的事件交互"><a href="#3、UI的事件交互" class="headerlink" title="3、UI的事件交互"></a>3、UI的事件交互</h2><p>事件的三个要素：</p><p><img src="/post/image-20230311150759513.png" alt="image-20230311150759513"></p><p>是否忽略Canvas反向的事件操作</p><p>遮挡事件的物体（2D物体[精灵片]，3D物体）</p><p>遮挡事件的物体所在的渲染层</p><p><img src="/post/image-20230311143908583.png" alt="image-20230311143908583"></p><p>Raycast Target：是否接收Canvas的射线</p><h3 id="1、button组件"><a href="#1、button组件" class="headerlink" title="1、button组件"></a>1、button组件</h3><p><img src="/post/image-20230312103320481.png" alt="image-20230312103320481"></p><p>按钮是否可交互</p><p>​          按钮状切换效果</p><p>​              动画效果影响的UI元素（Image和Text派生自Graphic）</p><p>​              效果使用的图片</p><p>​              普通状态下的颜色</p><p>​              高亮状态下的颜色（鼠标移入）</p><p>​              按下状态下的颜色（按钮按下）</p><p>​              失活状态下的颜色（不可交互）</p><p>​              颜色倍数（RGBA分量乘以倍数）</p><p>​              切换动画持续时间</p><p>​          是否开启键盘导航（Visualize开启后，能够看到导航线）</p><p>​              Navigation可以选择</p><p>​                   横向移动</p><p>​                   纵向移动</p><p>​                   自动匹配移动</p><p>​                   指定上下左右移动</p><p>​              手机游戏可以关闭导航</p><p><img src="/post/qushuiyin.jpg" alt="qushuiyin"></p><p><img src="/post/hello-world.assets/qushuiyin-1678724265134-6.jpg" alt="qushuiyin"></p><p><img src="/post/image-20230308201742994.png" alt="image">q</p><p><img src="/post/qushuiyin.jpg" alt="qushuiyin"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Unity-UI&quot;&gt;&lt;a href=&quot;#Unity-UI&quot; class=&quot;headerlink&quot; title=&quot;Unity UI&quot;&gt;&lt;/a&gt;Unity UI&lt;/h2&gt;&lt;h2 id=&quot;1、初步认识&quot;&gt;&lt;a href=&quot;#1、初步认识&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
</feed>
